---
layout: single
title:  "(회사 로그) lock 이슈 해결 "
categories: log
tag: [log, db, lock ]
toc: true
author_profile: true
---

### 이슈 현상

- **A 테이블 삭제 배치 도는 중에 사용자로부터 (개별) 삭제 요청이 오면 lock 발생 → 느려짐**
- 병목 지점
    - 알림 센터 개별 메시지 삭제 (delete)
    - 전체 갱신 update
- mssql 사용
- **파티션 나누면 해결되지만(lock 범위가 분리되므로), mssql 버전이 오래돼서 파티션 못 만듦**

### 성능 이슈 원인

- 배치 delete 범위가 너무 넓음(14일 전, 2만 건씩) → 그만큼 lock이 걸리는 범위가 넓어짐.
- **한번 delete 돌때 잡는 lock의 범위를 줄이기 위한 방안 2가지**
    1. 우선 삭제 대상 레코드의 pk 값들을 리스트로 가져옴 
    → 해당 리스트를 몇 개의 덩어리로 나누어서 반복문 돌며 삭제하면, 삭제 한 번에 잡는 lock 범위가 좁아짐
    → 따라서 배치 도중 개별 삭제 요청이 들어와도 lock 범위가 겹칠 가능성 적어짐. 그리고 lock이 걸리더라도 상대적으로 짧은 시간에 처리하므로 lock 걸리는 시간이 짧아짐
    
    1. IN-LIST 제거를 위해 PK 값들을 가져오지 않고 바로 DELETE 쿼리에서 TOP N 쿼리 사용

## 해결

### 이전 쿼리 (튜닝 전)

```java
delete from A
where id in (
	select top (#{removeGrp})  // 25000건
		id
	from A with (NOLOCK)
	where sendDate < dateadd(day, #{delayTime}, convert(datetime, convert(char(23), getDate(), 23) + '00:00:00.000'))
	order by id asc
)
```

### 튜닝 후

- 변경1 :
    
    ```sql
    <!-- 조건을 만족하는 msgId 리스트 25000건 가져오기-->
    select top (#{removeGrp})  // 25000건
    		id
    	from A with (NOLOCK)
    	where sendDate < dateadd(day, #{delayTime}, convert(datetime, convert(char(23), getDate(), 23) + '00:00:00.000'))
    ```
    
    ```sql
    <!-- 앞서 조회한 25000개의 msgId를 5개씩 나눠서 FOR문으로 삭제 처리 -->
    delete from A
    where id in 
    <foreach item="id" collection="pklist" open="(" separator="," close=")"> // 5건
    	#{id}
    </foreach>
    ```
    

- 변경2 (최종)
    
    ```sql
    delete top (#{removeGrp})     // 1000건
    from A
    where sendDate < dateadd(day, #{delayTime}, convert(datetime, convert(char(23), getDate(), 23) + '00:00:00.000'))
    and type = #{type, jdbcType=CHAR}
    ```
    

### **튜닝 포인트**

- order by 제거
    - top N 쿼리 + index 사용가능 →  부분 범위 처리 가능
    - 하지만 order by id (인덱스에 존재하지 않는 컬럼)을 해버리면 정렬을 위해 조건을 만족하는 모든 데이터가 일단 PGA에 올라와야함 (데이터가 상당히 많기 때문에 Temp 저장소를 사용할 것임) → I/O 과다 발생 + 부분 범위 처리 불가능
    
- 한번에 삭제하는 크기를 줄임 → lock 범위를 줄임
    - 25000건을 한번에 삭제하는데 걸리는 시간 : 5~7초
    - 위 작업을 실행하는 동안 단건 삭제 요청이 오면 (그리고 락 범위가 일치하면) 배치 삭제가 완료되어 lock이 해제될 때까지 기다려야 함 → 단건 삭제 요청을 처리하는 시간이 지연됨
    - 따라서 한 번에 삭제하는 양을 1000건으로 줄임 → 처리 시간 1초 미만
    
- 쿼리에서 IN-LIST 제거
    - IN-LIST가 FILTER 조건으로 풀릴 경우 → 모든 인덱스 리프 블록을 다 탐색해야함
    - IN-LIST가 UNION ALL로 풀릴 경우 → 인덱스 수직적 탐색이 많아짐. IN 조건 안에 데이터가 N건이면 수직적 탐색 N번 수행
        - 이 경우 때문에 한번에 삭제하는 건수를 5개로 설정 → 따라서 database call이 너무 많이 발생하고 처리 시간도 느려짐
    - 따라서 쿼리가 INDEX RANGE SCAN으로 풀리도록 쿼리 변경 (최종)
    
    +) 배치 삭제에서 삭제할 레코드의 id를 우선적으로 조회 → 삭제를 진행하기 전에 사용자가 해당 레코드를 삭제해버렸을 경우 → 오류 위험 존재
    
- 튜닝 결과 :
    - INDEX RANGE SCAN + 부분 범위 처리로 효율 증대
    - 단건 삭제 처리 시간 10초 → 1초로 단축
