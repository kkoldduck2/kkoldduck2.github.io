<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2022-09-12T23:09:17+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Woodi’s devlog</title><subtitle>woodi의 기술 블로그 입니다.</subtitle><author><name>Woodi</name></author><entry><title type="html">첫 포스팅입니다.</title><link href="http://localhost:4000/os/first/" rel="alternate" type="text/html" title="첫 포스팅입니다." /><published>2022-09-12T00:00:00+09:00</published><updated>2022-09-12T00:00:00+09:00</updated><id>http://localhost:4000/os/first</id><content type="html" xml:base="http://localhost:4000/os/first/"><![CDATA[<h1 id="오늘-처음-블로그를-만들었어요">오늘 처음 블로그를 만들었어요</h1>
<h3 id="세부-목차-1">세부 목차 1</h3>
<p>앞으로 열심히 해보겠습니다.</p>

<h3 id="세부-목차-2">세부 목차 2</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">print</span><span class="p">(</span><span class="s">"hello world"</span><span class="p">)</span>


</code></pre></div></div>]]></content><author><name>Woodi</name></author><category term="OS" /><category term="python" /><category term="jekyll" /><summary type="html"><![CDATA[오늘 처음 블로그를 만들었어요 세부 목차 1 앞으로 열심히 해보겠습니다.]]></summary></entry><entry><title type="html">카카오 등산코스 정하기</title><link href="http://localhost:4000/fail/kakao_118669/" rel="alternate" type="text/html" title="카카오 등산코스 정하기" /><published>2022-09-12T00:00:00+09:00</published><updated>2022-09-12T00:00:00+09:00</updated><id>http://localhost:4000/fail/kakao_118669</id><content type="html" xml:base="http://localhost:4000/fail/kakao_118669/"><![CDATA[<h3 id="문제">문제</h3>

<p><a href="https://school.programmers.co.kr/learn/courses/30/lessons/118669?language=java#">코딩테스트 연습 - 등산코스 정하기</a></p>

<p><strong>문제 요약</strong></p>

<ul>
  <li>등산코스를 따라 이동하는 중 쉼터 혹은 산봉우리를 방문할 때마다 휴식을 취할 수 있으며, 휴식 없이 이동해야 하는 시간 중 가장 긴 시간을 해당 등산코스의 <code class="language-plaintext highlighter-rouge">intensity</code>라고 부른다.</li>
  <li>등산 코스에서 출입구는 처음과 끝에 한 번씩, 산봉우리는 한 번만 포함되어야 한다.</li>
  <li>intensity가 최소가 되도록 등산코스를 정하라.</li>
</ul>

<h3 id="내-풀이">내 풀이</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Programmers_118669</span> <span class="o">{</span>
	<span class="kd">static</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Edge</span><span class="o">&gt;[]</span> <span class="n">graph</span><span class="o">;</span>
	<span class="kd">static</span> <span class="kt">int</span> <span class="no">N</span><span class="o">;</span>
	<span class="kd">static</span> <span class="kt">boolean</span><span class="o">[]</span> <span class="n">isGate</span><span class="o">;</span>
	<span class="kd">static</span> <span class="kt">boolean</span><span class="o">[]</span> <span class="n">isSummit</span><span class="o">;</span>
	<span class="kd">static</span> <span class="kd">class</span> <span class="nc">Edge</span> <span class="kd">implements</span> <span class="nc">Comparable</span><span class="o">&lt;</span><span class="nc">Edge</span><span class="o">&gt;{</span>
		<span class="kt">int</span> <span class="n">to</span><span class="o">;</span>
		<span class="kt">int</span> <span class="n">w</span><span class="o">;</span>
		<span class="kt">int</span> <span class="n">maxIntensity</span><span class="o">;</span>
		<span class="kd">public</span> <span class="nf">Edge</span><span class="o">(</span><span class="kt">int</span> <span class="n">to</span><span class="o">,</span> <span class="kt">int</span> <span class="n">w</span><span class="o">,</span> <span class="kt">int</span> <span class="n">maxIntensity</span><span class="o">)</span> <span class="o">{</span>
			<span class="k">this</span><span class="o">.</span><span class="na">to</span> <span class="o">=</span> <span class="n">to</span><span class="o">;</span>
			<span class="k">this</span><span class="o">.</span><span class="na">w</span> <span class="o">=</span> <span class="n">w</span><span class="o">;</span>
			<span class="k">this</span><span class="o">.</span><span class="na">maxIntensity</span> <span class="o">=</span> <span class="n">maxIntensity</span><span class="o">;</span> 
		<span class="o">}</span>
		
		<span class="nd">@Override</span>
		<span class="kd">public</span> <span class="kt">int</span> <span class="nf">compareTo</span><span class="o">(</span><span class="nc">Edge</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
			<span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">w</span> <span class="o">-</span> <span class="n">o</span><span class="o">.</span><span class="na">w</span><span class="o">;</span>
		<span class="o">}</span>
	<span class="o">}</span>
	
	<span class="c1">// gate -&gt; summit intensity</span>
	<span class="kd">static</span> <span class="kt">int</span> <span class="nf">getIntensity</span><span class="o">(</span><span class="kt">int</span> <span class="n">gate</span><span class="o">,</span> <span class="kt">int</span> <span class="n">summit</span><span class="o">)</span> <span class="o">{</span>
		<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"gate : "</span><span class="o">+</span><span class="n">gate</span><span class="o">+</span><span class="s">", summit : "</span><span class="o">+</span><span class="n">summit</span><span class="o">);</span>
		<span class="kt">boolean</span><span class="o">[]</span> <span class="n">visited</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="no">N</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span>
		<span class="n">visited</span><span class="o">[</span><span class="n">gate</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
		
		
		<span class="nc">PriorityQueue</span><span class="o">&lt;</span><span class="nc">Edge</span><span class="o">&gt;</span> <span class="n">pq</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PriorityQueue</span><span class="o">&lt;&gt;();</span>
		<span class="k">for</span><span class="o">(</span><span class="nc">Edge</span> <span class="n">e</span> <span class="o">:</span> <span class="n">graph</span><span class="o">[</span><span class="n">gate</span><span class="o">])</span> <span class="o">{</span>
			<span class="n">pq</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
		<span class="o">}</span>
		
		<span class="kt">int</span> <span class="n">intensityRst</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>
		
		<span class="c1">// visit 체크를 언제 해줘야하지?</span>
		<span class="k">while</span><span class="o">(!</span><span class="n">pq</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
			<span class="nc">Edge</span> <span class="n">now</span> <span class="o">=</span> <span class="n">pq</span><span class="o">.</span><span class="na">remove</span><span class="o">();</span>
			<span class="n">visited</span><span class="o">[</span><span class="n">now</span><span class="o">.</span><span class="na">to</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
			
			<span class="k">if</span><span class="o">(</span><span class="n">now</span><span class="o">.</span><span class="na">to</span> <span class="o">==</span> <span class="n">summit</span><span class="o">)</span> <span class="o">{</span>
				<span class="n">intensityRst</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">now</span><span class="o">.</span><span class="na">maxIntensity</span><span class="o">,</span> <span class="n">intensityRst</span><span class="o">);</span>
				<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"arrive : "</span><span class="o">+</span><span class="n">now</span><span class="o">.</span><span class="na">to</span><span class="o">+</span><span class="s">", "</span><span class="o">+</span><span class="n">now</span><span class="o">.</span><span class="na">w</span><span class="o">+</span><span class="s">", "</span><span class="o">+</span><span class="n">intensityRst</span><span class="o">);</span>
<span class="c1">//				break;</span>
			<span class="o">}</span> <span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="n">isSummit</span><span class="o">[</span><span class="n">now</span><span class="o">.</span><span class="na">to</span><span class="o">]</span> <span class="o">||</span> <span class="n">isGate</span><span class="o">[</span><span class="n">now</span><span class="o">.</span><span class="na">to</span><span class="o">])</span> <span class="o">{</span>
				<span class="k">continue</span><span class="o">;</span>
			<span class="o">}</span>
			
			<span class="k">for</span><span class="o">(</span><span class="nc">Edge</span> <span class="n">next</span> <span class="o">:</span> <span class="n">graph</span><span class="o">[</span><span class="n">now</span><span class="o">.</span><span class="na">to</span><span class="o">])</span> <span class="o">{</span>
				<span class="k">if</span><span class="o">(!</span><span class="n">visited</span><span class="o">[</span><span class="n">next</span><span class="o">.</span><span class="na">to</span><span class="o">])</span> <span class="o">{</span>
					<span class="kt">int</span> <span class="n">biggerIntensity</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">now</span><span class="o">.</span><span class="na">maxIntensity</span><span class="o">,</span> <span class="n">next</span><span class="o">.</span><span class="na">w</span><span class="o">);</span>
					<span class="n">pq</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">Edge</span><span class="o">(</span><span class="n">next</span><span class="o">.</span><span class="na">to</span><span class="o">,</span> <span class="n">next</span><span class="o">.</span><span class="na">w</span><span class="o">,</span> <span class="n">biggerIntensity</span><span class="o">));</span>
					
				<span class="o">}</span>
			<span class="o">}</span>
		<span class="o">}</span>
		
		<span class="k">return</span> <span class="n">intensityRst</span><span class="o">;</span>
	<span class="o">}</span> 
	
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">solution</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">,</span> <span class="kt">int</span><span class="o">[][]</span> <span class="n">paths</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">gates</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">summits</span><span class="o">)</span> <span class="o">{</span>
		<span class="no">N</span> <span class="o">=</span> <span class="n">n</span><span class="o">;</span>
		<span class="n">isGate</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span>
		<span class="n">isSummit</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span>
		<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">gates</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
			<span class="n">isGate</span><span class="o">[</span><span class="n">gates</span><span class="o">[</span><span class="n">i</span><span class="o">]]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
		<span class="o">}</span>
		<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">summits</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
			<span class="n">isSummit</span><span class="o">[</span><span class="n">summits</span><span class="o">[</span><span class="n">i</span><span class="o">]]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
		<span class="o">}</span>
		
        <span class="kt">int</span><span class="o">[]</span> <span class="n">answer</span> <span class="o">=</span> <span class="o">{};</span>
        <span class="c1">// 그래프 만들기</span>
        <span class="n">graph</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
        	<span class="n">graph</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="o">}</span>
        
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">paths</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
        	<span class="kt">int</span> <span class="n">u</span> <span class="o">=</span> <span class="n">paths</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">];</span>
        	<span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="n">paths</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">1</span><span class="o">];</span>
        	<span class="kt">int</span> <span class="n">w</span> <span class="o">=</span> <span class="n">paths</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">2</span><span class="o">];</span>
        	
        	<span class="k">if</span><span class="o">(</span><span class="n">isGate</span><span class="o">[</span><span class="n">u</span><span class="o">]</span> <span class="o">||</span> <span class="n">isSummit</span><span class="o">[</span><span class="n">v</span><span class="o">])</span> <span class="o">{</span>
        		<span class="n">graph</span><span class="o">[</span><span class="n">u</span><span class="o">].</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">Edge</span><span class="o">(</span><span class="n">v</span><span class="o">,</span> <span class="n">w</span><span class="o">,</span> <span class="n">w</span><span class="o">));</span>
        	<span class="o">}</span><span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="n">isGate</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">||</span> <span class="n">isSummit</span><span class="o">[</span><span class="n">u</span><span class="o">])</span> <span class="o">{</span>
        		<span class="n">graph</span><span class="o">[</span><span class="n">v</span><span class="o">].</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">Edge</span><span class="o">(</span><span class="n">u</span><span class="o">,</span><span class="n">w</span><span class="o">,</span> <span class="n">w</span><span class="o">));</span>
        	<span class="o">}</span><span class="k">else</span> <span class="o">{</span>
        		<span class="n">graph</span><span class="o">[</span><span class="n">u</span><span class="o">].</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">Edge</span><span class="o">(</span><span class="n">v</span><span class="o">,</span> <span class="n">w</span><span class="o">,</span> <span class="n">w</span><span class="o">));</span>
        		<span class="n">graph</span><span class="o">[</span><span class="n">v</span><span class="o">].</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">Edge</span><span class="o">(</span><span class="n">u</span><span class="o">,</span><span class="n">w</span><span class="o">,</span> <span class="n">w</span><span class="o">));</span>
        	<span class="o">}</span>
        <span class="o">}</span>
        
        <span class="kt">int</span> <span class="n">minIntensity</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">minSummit</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
        
        <span class="c1">// 출발지 선택</span>
        <span class="c1">// summit 선택</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">gates</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
        	<span class="kt">int</span> <span class="n">gate</span> <span class="o">=</span> <span class="n">gates</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
        	<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">summits</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
        		<span class="kt">int</span> <span class="n">summit</span> <span class="o">=</span> <span class="n">summits</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
        		<span class="c1">// 출발지 -&gt; summit -&gt; 출발지에 대한 intensity 구하기 -&gt; 최소인 경우 산봉우리 번호, intensity update</span>
        		<span class="kt">int</span> <span class="n">intensity</span> <span class="o">=</span> <span class="n">getIntensity</span><span class="o">(</span><span class="n">gate</span><span class="o">,</span> <span class="n">summit</span><span class="o">);</span>
        		<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"back : "</span><span class="o">+</span><span class="n">gate</span><span class="o">+</span><span class="s">", "</span><span class="o">+</span><span class="n">summit</span><span class="o">+</span><span class="s">", "</span><span class="o">+</span><span class="n">intensity</span><span class="o">);</span>
        		
        		<span class="k">if</span><span class="o">(</span><span class="n">minIntensity</span> <span class="o">&gt;</span> <span class="n">intensity</span><span class="o">)</span> <span class="o">{</span>
        			<span class="n">minIntensity</span> <span class="o">=</span> <span class="n">intensity</span><span class="o">;</span>
        			<span class="n">minSummit</span> <span class="o">=</span> <span class="n">summit</span><span class="o">;</span>
        		<span class="o">}</span>
        	<span class="o">}</span>
        <span class="o">}</span>
        
        <span class="n">answer</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]</span> <span class="o">{</span><span class="n">minSummit</span><span class="o">,</span> <span class="n">minIntensity</span><span class="o">};</span>
        <span class="k">return</span> <span class="n">answer</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<ul>
  <li>헷갈린 부분 : visit 체크</li>
  <li>정답은 맞는데 시간 초과 뜸 → 최적화 필요</li>
  <li>최적화 대상 → 이중 for 문 제거, 다익스트라 → 모든 gate에서 모든 정점 대상으로 최소값 갱신만 해주면 된다. (다익스트라라고 하는데 다익스트라는 아닌듯. 비슷한데 다름)</li>
</ul>

<h3 id="해설">해설</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Programmers_118669</span> <span class="o">{</span>
	<span class="kd">static</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Edge</span><span class="o">&gt;[]</span> <span class="n">graph</span><span class="o">;</span>
	<span class="kd">static</span> <span class="kd">class</span> <span class="nc">Edge</span> <span class="o">{</span>
		<span class="kt">int</span> <span class="n">to</span><span class="o">;</span>
		<span class="kt">int</span> <span class="n">w</span><span class="o">;</span>
		<span class="kd">public</span> <span class="nf">Edge</span><span class="o">(</span><span class="kt">int</span> <span class="n">to</span><span class="o">,</span> <span class="kt">int</span> <span class="n">w</span><span class="o">)</span> <span class="o">{</span>
			<span class="k">this</span><span class="o">.</span><span class="na">to</span> <span class="o">=</span> <span class="n">to</span><span class="o">;</span>
			<span class="k">this</span><span class="o">.</span><span class="na">w</span> <span class="o">=</span> <span class="n">w</span><span class="o">;</span>
		<span class="o">}</span>
	<span class="o">}</span>
	
	<span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">dijkstra</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">gates</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">summits</span><span class="o">)</span> <span class="o">{</span>
		<span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">Edge</span><span class="o">&gt;</span> <span class="n">q</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
		<span class="kt">int</span><span class="o">[]</span> <span class="n">intensity</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span>	<span class="c1">// intensity[i] : i번 노드까지 모든 출발지 -&gt; 모든 노드까지의 모든 경로 중에서 최소 intensity가 담긴다. </span>
		
		<span class="nc">Arrays</span><span class="o">.</span><span class="na">fill</span><span class="o">(</span><span class="n">intensity</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">);</span>
		
		<span class="c1">// 출입구 전부를 큐에 넣음</span>
		<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">gate</span> <span class="o">:</span> <span class="n">gates</span><span class="o">)</span> <span class="o">{</span>
			<span class="n">q</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">Edge</span><span class="o">(</span><span class="n">gate</span><span class="o">,</span> <span class="mi">0</span><span class="o">));</span>		<span class="c1">// 이때 가중치를 0으로 넣음. 의미적으로 가중치가 아니라 intensity</span>
			<span class="n">intensity</span><span class="o">[</span><span class="n">gate</span><span class="o">]</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> 
		<span class="o">}</span>
		
		<span class="k">while</span><span class="o">(!</span><span class="n">q</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
			<span class="nc">Edge</span> <span class="n">now</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="na">remove</span><span class="o">();</span>
			
			<span class="k">if</span><span class="o">(</span><span class="n">now</span><span class="o">.</span><span class="na">w</span> <span class="o">&lt;</span> <span class="n">intensity</span><span class="o">[</span><span class="n">now</span><span class="o">.</span><span class="na">to</span><span class="o">])</span> <span class="k">continue</span><span class="o">;</span>	<span class="c1">// pruning</span>
			
			<span class="k">for</span><span class="o">(</span><span class="nc">Edge</span> <span class="n">next</span> <span class="o">:</span> <span class="n">graph</span><span class="o">[</span><span class="n">now</span><span class="o">.</span><span class="na">to</span><span class="o">])</span> <span class="o">{</span>
				<span class="c1">// next.to까지의 최소 intensity 갱신</span>
				<span class="kt">int</span> <span class="n">dis</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">intensity</span><span class="o">[</span><span class="n">now</span><span class="o">.</span><span class="na">to</span><span class="o">],</span> <span class="n">next</span><span class="o">.</span><span class="na">w</span><span class="o">);</span>
				<span class="k">if</span><span class="o">(</span><span class="n">intensity</span><span class="o">[</span><span class="n">next</span><span class="o">.</span><span class="na">to</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">dis</span><span class="o">)</span> <span class="o">{</span>
					<span class="n">intensity</span><span class="o">[</span><span class="n">next</span><span class="o">.</span><span class="na">to</span><span class="o">]</span> <span class="o">=</span> <span class="n">dis</span><span class="o">;</span>
					<span class="n">q</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">Edge</span><span class="o">(</span><span class="n">next</span><span class="o">.</span><span class="na">to</span><span class="o">,</span> <span class="n">dis</span><span class="o">));</span>
				<span class="o">}</span>
			<span class="o">}</span>
		<span class="o">}</span>
		
		<span class="kt">int</span> <span class="n">rstSummit</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>
		<span class="kt">int</span> <span class="n">rstIntensity</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>
		
		<span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">summits</span><span class="o">);</span>
		
		<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">summit</span> <span class="o">:</span> <span class="n">summits</span><span class="o">)</span> <span class="o">{</span>
			<span class="k">if</span><span class="o">(</span><span class="n">intensity</span><span class="o">[</span><span class="n">summit</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">rstIntensity</span><span class="o">)</span> <span class="o">{</span>
				<span class="n">rstSummit</span> <span class="o">=</span> <span class="n">summit</span><span class="o">;</span>
				<span class="n">rstIntensity</span> <span class="o">=</span> <span class="n">intensity</span><span class="o">[</span><span class="n">summit</span><span class="o">];</span>
			<span class="o">}</span>
		<span class="o">}</span>
		
		<span class="k">return</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]</span> <span class="o">{</span><span class="n">rstSummit</span><span class="o">,</span> <span class="n">rstIntensity</span><span class="o">};</span>
	<span class="o">}</span>
	
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">solution</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">,</span> <span class="kt">int</span><span class="o">[][]</span> <span class="n">paths</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">gates</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">summits</span><span class="o">)</span> <span class="o">{</span>
		<span class="kt">boolean</span><span class="o">[]</span> <span class="n">isGate</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span>
		<span class="kt">boolean</span><span class="o">[]</span> <span class="n">isSummit</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span>
		<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">gates</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
			<span class="n">isGate</span><span class="o">[</span><span class="n">gates</span><span class="o">[</span><span class="n">i</span><span class="o">]]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
		<span class="o">}</span>
		<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">summits</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
			<span class="n">isSummit</span><span class="o">[</span><span class="n">summits</span><span class="o">[</span><span class="n">i</span><span class="o">]]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
		<span class="o">}</span>
		
        <span class="c1">// 그래프 만들기</span>
        <span class="n">graph</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
        	<span class="n">graph</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="o">}</span>
        
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">paths</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
        	<span class="kt">int</span> <span class="n">u</span> <span class="o">=</span> <span class="n">paths</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">];</span>
        	<span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="n">paths</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">1</span><span class="o">];</span>
        	<span class="kt">int</span> <span class="n">w</span> <span class="o">=</span> <span class="n">paths</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">2</span><span class="o">];</span>
        	
        	<span class="k">if</span><span class="o">(</span><span class="n">isGate</span><span class="o">[</span><span class="n">u</span><span class="o">]</span> <span class="o">||</span> <span class="n">isSummit</span><span class="o">[</span><span class="n">v</span><span class="o">])</span> <span class="o">{</span>
        		<span class="n">graph</span><span class="o">[</span><span class="n">u</span><span class="o">].</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">Edge</span><span class="o">(</span><span class="n">v</span><span class="o">,</span> <span class="n">w</span><span class="o">));</span>
        	<span class="o">}</span><span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="n">isGate</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">||</span> <span class="n">isSummit</span><span class="o">[</span><span class="n">u</span><span class="o">])</span> <span class="o">{</span>
        		<span class="n">graph</span><span class="o">[</span><span class="n">v</span><span class="o">].</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">Edge</span><span class="o">(</span><span class="n">u</span><span class="o">,</span><span class="n">w</span><span class="o">));</span>
        	<span class="o">}</span><span class="k">else</span> <span class="o">{</span>
        		<span class="n">graph</span><span class="o">[</span><span class="n">u</span><span class="o">].</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">Edge</span><span class="o">(</span><span class="n">v</span><span class="o">,</span> <span class="n">w</span><span class="o">));</span>
        		<span class="n">graph</span><span class="o">[</span><span class="n">v</span><span class="o">].</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">Edge</span><span class="o">(</span><span class="n">u</span><span class="o">,</span><span class="n">w</span><span class="o">));</span>
        	<span class="o">}</span>
        <span class="o">}</span>
        
        <span class="k">return</span> <span class="nf">dijkstra</span><span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="n">gates</span><span class="o">,</span> <span class="n">summits</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<ul>
  <li>애초에 visit 체크도 안 넣는다.</li>
  <li>모든 노드에 대한 intensity를 배열에 저장한다. (나는 Node 자체에 변수로 넣어두고, 최대값만 override했음) 
⇒ 따라서 bfs 탐색을 한번만 하면 된다.</li>
</ul>]]></content><author><name>Woodi</name></author><category term="fail" /><category term="알고리즘" /><category term="fail" /><category term="카카오" /><category term="프로그래머스" /><category term="118669번" /><summary type="html"><![CDATA[문제]]></summary></entry><entry><title type="html">프로세스와 스레드 차이</title><link href="http://localhost:4000/os/process_vs_thread/" rel="alternate" type="text/html" title="프로세스와 스레드 차이" /><published>2022-09-12T00:00:00+09:00</published><updated>2022-09-12T00:00:00+09:00</updated><id>http://localhost:4000/os/process_vs_thread</id><content type="html" xml:base="http://localhost:4000/os/process_vs_thread/"><![CDATA[<h2 id="프로세스와-스레드의-차이">프로세스와 스레드의 차이</h2>

<h3 id="프로세스process란">프로세스(Process)란</h3>

<ul>
  <li>메모리에 올라와 실행되고 있는 프로그램의 인스턴스</li>
  <li>운영체제로부터 <strong>시스템 자원을 할당</strong> 받는 <strong>작업의 단위</strong>
    <ul>
      <li>할당받는 시스템 자원의 예
        <ul>
          <li>CPU 시간</li>
          <li>운영되기 위해 필요한 주소 공간</li>
          <li>Code, Data, Stack, Heap의 구조로 되어 있는 독립된 메모리 영역</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>즉, 동적인 개념으로는 <strong>실행된 프로그램</strong>을 의미한다.</li>
  <li>
    <p>프로세스는 각각 독립된 메모리 영역(Code, Data, Stack, Heap의 구조)을 할당받는다.</p>

    <p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/4169bcd5-9d7d-4242-89dd-0945f4bf1f1d/Untitled.png" alt="Untitled" /></p>

    <ul>
      <li><strong>Code, Data, Heap, Stack</strong>
        <ul>
          <li>Code 영역 : 프로세스가 실행할 코드가 기계어의 형태로 저장된 공간이다. (컴파일 타임에 결정, Read-Only)</li>
          <li>Data 영역 : 전역 변수, static 변수 등이 저장된 공간이다. static 변수를 참조한 코드는 컴파일된 후 데이터 영역의 주소값을 가르킨다 (컴파일 타임에 결정, Read-Write: 실행 도중 변경 가능)</li>
          <li>Heap 영역 : 프로그래머가 관리하는 메모리 영역으로, 힙 영역에 메모리를 할당하는 것을 동적 할당이라고 한다. <strong>데이터 배열의 크기가 확실하지 않고 변동이 있을 때 Heap 영역을 활용해서 메모리를 할당</strong>한다. 단 <strong>사용하고 난 다음에는 반드시 해제를 해야한다</strong>. 안그러면 memory leak이 발생한다.  (런타임에 결정, 스택보다 할당 할 수 있는 메모리 공간이 많으나, 포인터로 메모리 영역을 접근해야하기 때문에 다른 자료구조에 비해서 데이터 읽고 쓰기가 느림)</li>
          <li>Stack 영역 : 함수 안에서 선언된 지역변수, 매개변수, 리턴값, 복귀 주소 등이 저장된다. 스택의 LIFO 방식에 따라 함수 호출 시 기록하고 종료되면 제거한다. (컴파일 타임에 결정, 정해진 크기가 있으므로 stack overflow 에러 발생 가능)</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>각 프로세스는 별도의 (독립된) 주소 공간에서 실행되며, 한 프로세스는 다른 프로세스의 변수나 자료구조에 접근할 수 없다.</li>
  <li>한 프로세스가 다른 프로세스의 자원에 접근하려면 프로세스 간의 통신(IPC)을 사용해야 한다. (ex. 파이프, 파일, 소켓 등을 이용한 통신 방법 이용)</li>
</ul>

<h3 id="스레드-thread란">스레드 (Thread)란</h3>

<ul>
  <li>프로세스가 할당 받은 자원을 이용하는 <strong>실행의 단위 (=</strong> 한 프로세스 내에서 동작하는 여러 실행의 흐름)</li>
</ul>

<p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/75619b36-056c-446b-82e4-164fd5da54b1/Untitled.png" alt="Untitled" /></p>

<ul>
  <li>스레드는 프로세스 내에서 각각 <strong>Stack만 따로 할당</strong>받고 <strong>Code, Data, Heap 영역은 공유</strong>한다.
    <ul>
      <li>같은 <strong>프로세스 내에 스레드끼리는 프로세스 내의 주소 공간이나 자원들 (힙 공간 등)을 공유</strong>하면서 실행된다.</li>
    </ul>
  </li>
  <li>한 스레드가 프로세스 자원을 변경하면, 다른 이웃 스레드(siblig thread)도 그 변경 결과를 즉시 볼 수 있다.</li>
</ul>

<h3 id="자바-스레드-java-thread란">자바 스레드 (Java Thread)란</h3>

<ul>
  <li>일반 스레드와 거의 차이가 없으며, <strong>JVM이 운영체제의 역할</strong>을 한다.</li>
  <li>자바에는 프로세스가 존재하지 않고 스레드만 존재하며, <strong>자바 스레드는 JVM에 의해 스케줄되는 실행 단위 코드 블록</strong>이다.</li>
  <li>자바에서 스레드 스케줄링은 전적으로 JVM에 의해 이루어진다.  (그 외에도 스레드가 몇 개 존재하는지, 스레드로 실행되는 프로그램 코드의 메모리 위치는 어디인지, 스레드의 상태는 무엇인지, 스레드의 우선순위는 얼마인지 등과 같은 정보들도 JVM이 관리한다.)</li>
  <li>즉, 개발자는 자바 스레드로 작동할 스레드 코드를 작성하고, 스레드 코드가 생명을 가지고 실행을 시작하도록 JVM에 요청하는 일 뿐이다.</li>
</ul>

<h2 id="멀티-프로세스-대신-멀티-스레드를-사용하는-이유">멀티 프로세스 대신 멀티 스레드를 사용하는 이유</h2>

<p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/84df54e3-23a1-492b-ac5e-af3816ed428d/Untitled.png" alt="Untitled" /></p>

<ul>
  <li>쉽게 말하면, 프로그램을 여러 개 실행하는 것보다, 하나의 프로그램 안에서 여러 작업을 해결하는 것이다.</li>
</ul>

<ol>
  <li><strong>자원의 효율성 증대</strong>
    <ul>
      <li>멀티 프로세스 → 멀티 스레드로 실행할 경우, <strong>프로세스를 생성하여 자원을 할당</strong>하는 시스템 콜이 줄어들어 <strong>자원을 효율적으로 관리</strong>할 수 있다.</li>
    </ul>
  </li>
  <li><strong>처리 비용 감소 및 응답 시간 단축</strong>
    <ul>
      <li>스레드는 프로세스 내의 <strong>메모리를 공유하기 때문에</strong> 독립적인 프로세스와 달리 <strong>스레드 간 데이터를 주고 받는 것이 간단해짐 →</strong> 프로세스 간의 통신 (IPC)보다 스레드 간의 통신 비용이 적으므로 작업들 간의 통신 부담이 줄어든다.</li>
      <li>프로세스 간의 전환 속도보다 스레드 간의 전환 속도가 빠르다.
        <ul>
          <li>Context Switching 시
            <ul>
              <li>프로세스 : CPU 레지스터 교체, RAM과 CPU 사이의 캐시 메모리에 대한 데이터까지 초기화 → 오버헤드가 크다.</li>
              <li>스레드 :  Stack 영역만 처리한다.</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ol>

<p><strong>주의할 점!</strong></p>

<ul>
  <li><strong>동기화 문제</strong></li>
  <li>스레드 간의 자원 공유는 전역 변수(데이터 세그먼트)를 이용하므로 함께 사용할 때 충돌이 발생할 수 있다.</li>
</ul>

<h2 id="thread-safe">Thread-safe</h2>

<ul>
  <li><strong>Thread-safe란?</strong>
    <ul>
      <li>멀티 스레드 환경에서 여러 스레드가 동시에 하나의 객체 및 변수(공유자원)에 접근할 때, 의도한 대로 동작하는 것을 말한다.</li>
    </ul>
  </li>
  <li><strong>Thread-safe하게 구현하기</strong>
    <ul>
      <li>Thread-safe하기 위해서는 <strong>공유 자원에 접근하는 임계영역(critical section)을 동기화 기법으로 제어</strong>해줘야 한다.  ⇒ 이를 ‘상호배제’라고 한다.</li>
      <li>동기화 기법으로는 Mutex나 Semaphore 등이 있다.</li>
    </ul>
  </li>
</ul>]]></content><author><name>Woodi</name></author><category term="OS" /><category term="os" /><category term="cs" /><summary type="html"><![CDATA[프로세스와 스레드의 차이]]></summary></entry><entry><title type="html">제플린이란</title><link href="http://localhost:4000/opensource/zeppelin/" rel="alternate" type="text/html" title="제플린이란" /><published>2022-09-12T00:00:00+09:00</published><updated>2022-09-12T00:00:00+09:00</updated><id>http://localhost:4000/opensource/zeppelin</id><content type="html" xml:base="http://localhost:4000/opensource/zeppelin/"><![CDATA[<ul>
  <li>spark : 빅데이터 분석 도구, but CLI만 사용 가능</li>
  <li>데이터 분석 업무를 하다보면, 여러가지 알고리즘과 파라미터를 바꿔가며 분석 결과를 반복해서 그래프나 테이블 같은 형태로 시각화하여 확인해야 하는데 커맨드 라인 도구는 불편하다.</li>
</ul>

<p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/4837c03b-2827-49bb-b30c-b205d56b5f78/Untitled.png" alt="Untitled" /></p>

<ul>
  <li>Apache Zeppelin은 Spark를 통한 데이터 분석의 불편함을 Web 기반의 Notebook을 통해서 해결해보고자 만들어진 어플리케이션이다.</li>
  <li>사용자들은 Zeppelin을 이용하여 Web에서 Python, Scala 등의 다양한 언어를 섞어가며 분석 코드를 짤 수 있고 이 결과를 바로 Graph로 시각화하여 볼 수 있다.</li>
  <li>여기에 더해 Zeppelin은 넓어져가는 빅데이터 분석도구 시장의 다양한 니즈에 맞추기 위해서 Spark 뿐만이 아닌 Livy, Cassandra, Lens, SQL 등등의 다른 데이터 분석 도구나 데이터베이스에 접근하여 쿼리하는 것을 쉽게 할 수 있는 확장 기능들을 지원한다.</li>
</ul>

<h3 id="zeppelin-사용">Zeppelin 사용</h3>

<ul>
  <li><strong>오픈소스를 기반으로 빅데이터 분석 시스템을 구성하는 기업들은 다양한 기술 스택을 서로 엮어서 시스템을 구성</strong>하게 되는데 Zeppelin 하나만 있으면 이들 시스템의 각 요소들에 자유롭게 접근하여 데이터를 다룰 수 있게 된 것이다. 
→ 이러한 확장성 때문에 Zeppelin은 후발주자임에도 매우 빠르게 여러 기업들에 사용되기 시작했고 널리 알려지게 된 것이다.</li>
</ul>

<h3 id="zeppelin---interpreter-플러그인">Zeppelin - Interpreter 플러그인</h3>

<ul>
  <li>이러한 확장성은 Zeppelin의 <strong>Interpreter라는 플러그인 구조</strong>로 지원되는데 각 Interpreter들은 Zeppelin의 Web Interface를 통해서 입력받은 분석 코드를 local 또는 원격에서 실행할 수 있다.</li>
  <li>예) Spark로 Map_reduce하는 코드를 작성하고 실행을 누르면, Zeppelin 안에 설치된 Spark Interpreter가 이를 받아 spark Master의 Client 라이브러리를 통해 코드를 보내고 그 실행 결과를 받아 다시 Web Interface에 보내준다.</li>
</ul>

<p>또한 Bash로 쉘 스크립트를 짜면 Zeppelin 안에 탑재된 Shell Interpreter가 이를 받아 Zeppelin이 설치된 서버에서 Shell script를 실행하고 그 결과를 Web Interface에 보내주는 형태이다.</p>

<p>Z<strong>eppelin 자체가 데이터 분석 처리를 하지 않기 때문에</strong> 분석 시스템이나 데이터베이스 등이 미리 구성되어 있어야 하고, Zeppelin과 이들 시스템을 연결해주는 작업을 해야 한다는 어려움이 있지만 한번 연결해 두면 <strong>같은 Notebook에서 Pyspark와 SparkR그리고 Cassandra DB를 한번에 조회</strong>하는 등의 일을 편하게 할 수 있는 장점이 있다.</p>

<p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ca58ace8-a164-4d8b-9d48-71987301d7c1/Untitled.png" alt="Untitled" /></p>

<h3 id="zeppelin의-협업-기능">Zeppelin의 협업 기능</h3>

<ul>
  <li>Google Sheet처럼 <strong>Zeppelin도 WebSocket을 활용하여 같은 Notebook을 여러 사람이 동시에 편집할 수 있는 기능을 제공</strong>하고 있다. 한 사람이 분석 코드를 짜면 다른 사람이 그 결과를 원격에서 실시간으로 바로 확인할 수 있는 것이다.</li>
  <li>또한 Zeppelin은 Angular JS를 활용하여 Web Interface가 만들어졌기 때문에 Angular JS의 장점인 Data Binding 기능을 응용한 보고서 또는 Dashboard 등을 만들 수 있다.</li>
</ul>

<h3 id="제플린-사용법">제플린 사용법</h3>

<p><a href="https://www.sunlab.org/teaching/cse6250/spring2018/lab/zeppelin-tutorial/">https://www.sunlab.org/teaching/cse6250/spring2018/lab/zeppelin-tutorial/</a></p>

<p><a href="https://www.youtube.com/watch?v=2EnSzydGPz8">https://www.youtube.com/watch?v=2EnSzydGPz8</a></p>]]></content><author><name>Woodi</name></author><category term="opensource" /><category term="opensource" /><category term="오픈소스" /><category term="제플린" /><category term="오픈소스컨트리뷰션" /><summary type="html"><![CDATA[spark : 빅데이터 분석 도구, but CLI만 사용 가능 데이터 분석 업무를 하다보면, 여러가지 알고리즘과 파라미터를 바꿔가며 분석 결과를 반복해서 그래프나 테이블 같은 형태로 시각화하여 확인해야 하는데 커맨드 라인 도구는 불편하다.]]></summary></entry></feed>